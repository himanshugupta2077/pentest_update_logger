import sys, os, json, re
from datetime import datetime
from PyQt6.QtWidgets import *
from PyQt6.QtCore import Qt, QTimer
from PyQt6.QtGui import QFont, QColor, QPalette, QClipboard
import anthropic

class PentestUpdateLogger(QMainWindow):
    def __init__(self):
        super().__init__()
        self.workspace = self.current_file = None
        self.entry_count = 0
        self.dark_mode = False
        self.last_saved_content = ""
        self.initUI()
        self.setup_autosave()
        self.prompt_workspace()

    def initUI(self):
        self.setWindowTitle('Pentest Update Logger')
        self.setGeometry(100, 100, 1200, 800)
        
        main_layout = QHBoxLayout()
        main_widget = QWidget()
        main_widget.setLayout(main_layout)
        self.setCentralWidget(main_widget)

        left_layout, right_layout = QVBoxLayout(), QVBoxLayout()
        left_widget, right_widget = QWidget(), QWidget()
        left_widget.setLayout(left_layout)
        right_widget.setLayout(right_layout)
        main_layout.addWidget(left_widget, 1)
        main_layout.addWidget(right_widget, 2)

        self.setup_left_side(left_layout)
        self.setup_right_side(right_layout)
        self.setup_menu()
        
        # Add mode switch button
        self.mode_switch = QPushButton('Switch to Dark Mode')
        self.mode_switch.clicked.connect(self.toggle_mode)
        right_layout.addWidget(self.mode_switch)

        # Add Copy All button
        self.copy_all_button = QPushButton('Copy All')
        self.copy_all_button.clicked.connect(self.copy_all_content)
        right_layout.addWidget(self.copy_all_button)

        self.set_light_mode()

    def setup_autosave(self):
        self.autosave_timer = QTimer(self)
        self.autosave_timer.timeout.connect(self.autosave)
        self.autosave_timer.start(1000)  # Trigger every 1000 ms (1 second)

    def autosave(self):
        current_content = self.output_text.toPlainText()
        if current_content != self.last_saved_content:
            self.save_file()
            self.last_saved_content = current_content

    def setup_left_side(self, layout):
        project_form = QFormLayout()
        self.project_name_input = QLineEdit()
        self.pentest_day_input = QLineEdit()
        project_form.addRow("Project Name:", self.project_name_input)
        project_form.addRow("Pentest Day:", self.pentest_day_input)
        layout.addLayout(project_form)

        self.file_list = QListWidget()
        self.file_list.itemClicked.connect(self.open_file)
        layout.addWidget(QLabel("Files:"))
        layout.addWidget(self.file_list)

    def setup_right_side(self, layout):
        self.process_button = QPushButton('Write')
        self.process_button.clicked.connect(self.confirm_process)
        layout.addWidget(self.process_button)

        self.fields = ['Testcase', 'URL', 'Location', 'Technique', 'Payload', 'Outcome']
        self.entries = {}
        for field in self.fields:
            self.entries[field] = QLineEdit()
            self.entries[field].setPlaceholderText(field)
            
            field_layout = QHBoxLayout()
            field_layout.addWidget(self.entries[field])
            layout.addLayout(field_layout)

        # Add Copy Details button
        self.copy_details_button = QPushButton('Copy Details from Entry')
        self.copy_details_button.clicked.connect(self.copy_details_from_entry)
        layout.addWidget(self.copy_details_button)

        button_layout = QHBoxLayout()
        for text, func in [('Add Entry', self.add_entry), 
                           ('Save', self.save_file), 
                           ('Save As', self.save_file_as)]:
            btn = QPushButton(text)
            btn.clicked.connect(func)
            button_layout.addWidget(btn)
        layout.addLayout(button_layout)

        self.output_text = QTextEdit()
        layout.addWidget(self.output_text)

    def confirm_process(self):
        reply = QMessageBox.question(self, 'Confirmation', 
                                     "Are you sure you want to process this file?",
                                     QMessageBox.StandardButton.Yes | 
                                     QMessageBox.StandardButton.No, 
                                     QMessageBox.StandardButton.No)
        if reply == QMessageBox.StandardButton.Yes:
            self.process_current_file()

    def anonymize_urls(self, content):
        url_pattern = re.compile(r'\*\*(.*?)\*\*')
        placeholders = {}
        
        def replace_url(match):
            url = match.group(1)
            placeholder = f'URL_PLACEHOLDER_{len(placeholders)}'
            placeholders[placeholder] = url
            return placeholder
        
        anonymized_content = url_pattern.sub(replace_url, content)
        return anonymized_content, placeholders

    def process_with_anthropic(self, content):
        client = anthropic.Anthropic(api_key=os.environ.get('ANTHROPIC_API_KEY'))
        prompt = f"""
        You are an expert penetration tester responsible for creating daily client updates on your testing activities. Your task is to transform complex technical information into clear, concise, and easily comprehensible summaries.
When crafting these updates, adhere to the following guidelines:
1. Analyze the provided technical details for each test case thoroughly.
2. Compose updates using varied sentence structures to avoid repetitive patterns. Alternate between first-person ("I") and third-person (passive voice) constructions.
3. When mentioning URLs, follow them with either "endpoint" or "URL" for clarity.
4. Incorporate phrases like "During the analysis, I observed that" or "During the analysis, it was observed that" to introduce findings.
5. Employ plain language, avoiding technical jargon where possible to ensure client understanding.
6. Structure each update as a single paragraph, typically containing 2-4 sentences.
7. Treat each update point as an independent item, avoiding references to other points.
8. Use complete URLs when provided in the technical details.
9. Do not use any numbers in the update points.
10. Update points should next line to each (no gaps).
To add variety and avoid predictable patterns, begin your updates with one of the following phrases, selected at random:
- "I worked in the [module name] on ... [url] by [technique] ... "
- "Test for [vulnerability name] was conducted on ... [url] by [technique] ..."
- "[functionality or module name] in [url] endpoint/URL was tested for [testcase] by [technique] ..."
- "While working in the page [module or page name], I found [module or functionality] functionality and tested for [testcase] at [url] by [technique] ..."
- "A [vulnerability name] test case was performed on [module name] ... at [url] by [technique] ..."
- "I continued working on [module name] and tested for [vulnerability name] at ... [url] by [technique] ..."
- "[vulnerability name] test case was conducted/performed on ... [vulnerability name] at [url] by [technique] ... "
- "The module/functionality [module/functionality name] was tested for [vulnerability name] at ... [url] by [technique] ..."
- "[Module name] was tested for [vulnerability name], in the [functionality/module] at ... [url] by [technique] ..."
- "I focused on testing for [vulnerability name] in the [functionality] of [module name] at ... [url] by [technique] ..."
When provided with technical details about a penetration test, generate updates following this format. Ensure the updates are informative yet accessible to non-technical clients.
Sample update points:
1. I worked in the collection module and tested for XSS in the query parameter in people functionality by uploading a malicious SVG image with XSS payload at https://example.com/knowledge/collections/437/testimage endpoint. During the analysis, I observed that the application is accepting the request and uploading the image but not executing the payload. I will work on this again.
2. A SQL injection test case was performed in the search team functionality in the Teams module at https://example.com/api/v1/listentities?clientVersion=fe-release-2024-06-27-3906dc2&locale=en URL by sending various SQL injection payloads to generate any errors by the application. During the analysis, it was observed that the application is not interpreting the payloads and responding normally.
3. Pins module was tested for XSS vulnerabilities in the query parameter in the Edit Pin functionality at https://example.com/api/v1/editpin?clientVersion=fe-release-2024-06-27-3906dc2&locale=en URL using various payloads to trigger an alert box. During the analysis, I observed that the application is not interpreting the payloads and encoding them before loading them on the screen.
Now, please convert multiple technical details into penetration testing updates. Write each update using either first person, beginning with "I," or in third person (passive voice). Vary the starting phrases to avoid patterns, using the provided options in random order.
        <user query>{content}</user query>
        """
        message = client.messages.create(
            model="claude-3-5-sonnet-20240620",
            max_tokens=1000,
            temperature=0,
            messages=[
                {
                    "role": "user",
                    "content": prompt
                }
            ]
        )
        processed_content = message.content[0].text
        return processed_content

    def reinsert_urls(self, content, placeholders):
        for placeholder, url in placeholders.items():
            content = content.replace(placeholder, f"{url}")
            content = re.sub(r'\n\n+', '\n', content)
        return content

    def process_current_file(self):
        if not self.current_file:
            QMessageBox.warning(self, "Warning", "No file is currently open.")
            return

        content = self.output_text.toPlainText()
        
        # Show processing indicator
        self.process_button.setEnabled(False)
        self.process_button.setText('Processing...')
        QApplication.processEvents()

        try:
            # Step 1: Anonymize URLs
            anonymized_content, placeholders = self.anonymize_urls(content)
            
            # Step 2: Process with Anthropic API
            print("\nAnonymized content sent to Anthropic API:\n")
            print(anonymized_content)
            processed_content = self.process_with_anthropic(anonymized_content)
            
            # Step 3: Reinsert URLs
            final_content = self.reinsert_urls(processed_content, placeholders)
            
            # Generate output file name
            output_file_path = self.current_file.rsplit('.', 1)[0].replace('_enteries', '') + '_updates.' + self.current_file.rsplit('.', 1)[1]
            
            # Save the processed content
            with open(output_file_path, 'w') as file:
                file.write(final_content)
            
            # Update the UI
            self.output_text.setPlainText(final_content)
            self.current_file = output_file_path
            self.update_file_list()
            
            # Copy content to clipboard
            clipboard = QApplication.clipboard()
            clipboard.setText(final_content)
            
            QMessageBox.information(self, "Success", f"Processed file saved as: {output_file_path}\nContent copied to clipboard.")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"An error occurred: {str(e)}")
        finally:
            # Reset processing button
            self.process_button.setEnabled(True)
            self.process_button.setText('Write')

    def copy_all_content(self):
        content = self.output_text.toPlainText()
        clipboard = QApplication.clipboard()
        clipboard.setText(content)
        QMessageBox.information(self, "Success", "All content copied to clipboard.")

    def prompt_workspace(self):
        workspace = QFileDialog.getExistingDirectory(self, "Select Workspace Folder")
        if workspace:
            self.workspace = workspace
            self.update_file_list()
            self.load_log_file()

    def load_log_file(self):
        log_file = os.path.join(self.workspace, 'pentest_log.json')
        if os.path.exists(log_file):
            with open(log_file, 'r') as f:
                log_data = json.load(f)
                self.project_name_input.setText(log_data.get('project_name', ''))
                self.pentest_day_input.setText(log_data.get('pentest_day', ''))

    def save_log_file(self):
        log_file = os.path.join(self.workspace, 'pentest_log.json')
        log_data = {
            'project_name': self.project_name_input.text(),
            'pentest_day': self.pentest_day_input.text()
        }
        with open(log_file, 'w') as f:
            json.dump(log_data, f)

    def copy_details_from_entry(self):
        entry_number, ok = QInputDialog.getInt(self, "Copy Details", "Enter the entry number:")
        if ok:
            content = self.output_text.toPlainText()
            entry_pattern = rf"Entry {entry_number}:(.*?)(?=Entry \d+:|$)"
            entry_match = re.search(entry_pattern, content, re.DOTALL)
            if entry_match:
                entry_content = entry_match.group(1).strip()
                for field, widget in self.entries.items():
                    field_pattern = rf"{field}: (.*?)(?=\n|$)"
                    field_match = re.search(field_pattern, entry_content, re.DOTALL)
                    if field_match:
                        if isinstance(widget, QComboBox):
                            index = widget.findText(field_match.group(1))
                            if index >= 0:
                                widget.setCurrentIndex(index)
                            else:
                                widget.setCurrentText(field_match.group(1))
                        else:
                            widget.setText(field_match.group(1))
            else:
                QMessageBox.warning(self, "Warning", f"Entry {entry_number} not found.")

    def setup_menu(self):
        menubar = self.menuBar()
        file_menu = menubar.addMenu('File')
        open_workspace_action = file_menu.addAction('Open Workspace')
        open_workspace_action.triggered.connect(self.open_workspace)

    def set_dark_mode(self):
        self.dark_mode = True
        self.mode_switch.setText('Switch to Light Mode')
        self.setStyleSheet("""
            QMainWindow, QWidget { background-color: #000000; color: #00FF00; }
            QLineEdit, QTextEdit, QComboBox { 
                background-color: #0A0A0A; 
                color: #00FF00; 
                border: 1px solid #00FF00; 
                border-radius: 5px; 
                padding: 2px;
            }
            QLineEdit:focus, QTextEdit:focus, QComboBox:focus { 
                border: 2px solid #00FF00; 
            }
            QPushButton { 
                background-color: #0A0A0A; 
                color: #00FF00; 
                border: 1px solid #00FF00; 
                border-radius: 5px;
                padding: 5px; 
            }
            QPushButton:hover { background-color: #00FF00; color: #000000; }
            QScrollBar:vertical, QScrollBar:horizontal { background-color: #0A0A0A; }
            QScrollBar::handle:vertical, QScrollBar::handle:horizontal { background-color: #00FF00; }
            QMenu { background-color: #0A0A0A; color: #00FF00; border: 1px solid #00FF00; }
            QMenu::item:selected { background-color: #00FF00; color: #000000; }
        """)

    def set_light_mode(self):
        self.dark_mode = False
        self.mode_switch.setText('Switch to Dark Mode')
        self.setStyleSheet("""
            QMainWindow, QWidget { background-color: #F0F0F0; color: #000000; }
            QLineEdit, QTextEdit, QComboBox { 
                background-color: #FFFFFF; 
                color: #000000; 
                border: 1px solid #C0C0C0; 
                border-radius: 5px;
                padding: 2px;
            }
            QLineEdit:focus, QTextEdit:focus, QComboBox:focus { 
                border: 2px solid #4A90E2; 
            }
            QPushButton { 
                background-color: #E0E0E0; 
                color: #000000; 
                border: 1px solid #C0C0C0; 
                border-radius: 5px;
                padding: 5px; 
            }
            QPushButton:hover { background-color: #D0D0D0; }
        """)

    def toggle_mode(self):
        if self.dark_mode:
            self.set_light_mode()
        else:
            self.set_dark_mode()

    def open_workspace(self):
        self.workspace = QFileDialog.getExistingDirectory(self, "Select Workspace Folder")
        if self.workspace:
            self.update_file_list()

    def update_file_list(self):
        self.file_list.clear()
        if self.workspace:
            self.file_list.addItems([f for f in os.listdir(self.workspace) if f.endswith('.txt')])

    def add_entry(self):
        if self.current_file:
            with open(self.current_file, 'r') as f:
                content = f.read()
                self.entry_count = max([int(m.group(1)) for m in re.finditer(r'Entry (\d+):', content)] or [0]) + 1
        else:
            self.entry_count += 1

        entry = f"Entry {self.entry_count}:\n"
        for field, widget in self.entries.items():
            if isinstance(widget, QComboBox):
                value = widget.currentText() if widget.currentIndex() != 0 else ""
            else:
                value = widget.text()
            
            if field == 'URL' and value:
                value = f"**{value}**"
            
            if value:
                entry += f"{field}: {value}\n"
        
        entry += "\n"
        self.output_text.append(entry)
        
        for widget in self.entries.values():
            if isinstance(widget, QComboBox):
                widget.setCurrentIndex(0)
            else:
                widget.clear()
        
        # Trigger autosave
        self.autosave()

    def save_file(self):
        if not self.current_file:
            self.save_file_as()
        else:
            try:
                with open(self.current_file, 'w') as f:
                    f.write(self.output_text.toPlainText())
                print("File saved successfully")
                self.save_log_file()
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to save file: {str(e)}")

    def save_file_as(self):
        if not self.workspace:
            QMessageBox.warning(self, "Warning", "Please open a workspace first.")
            return

        self.project_name, self.pentest_day = self.project_name_input.text(), self.pentest_day_input.text()
        if not self.project_name or not self.pentest_day:
            QMessageBox.warning(self, "Warning", "Please enter both Project Name and Pentest Day.")
            return

        filename = f"{self.project_name}_{self.pentest_day}_{datetime.now().strftime('%Y%m%d_%H%M%S')}_enteries.txt"
        file_path = os.path.join(self.workspace, filename)

        try:
            with open(file_path, 'w') as f:
                f.write(self.output_text.toPlainText())
            self.current_file = file_path
            self.update_file_list()
            QMessageBox.information(self, "Success", f"File saved as {filename}")
            self.save_log_file()
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to save file: {str(e)}")

    def open_file(self, item):
        if self.workspace:
            file_path = os.path.join(self.workspace, item.text())
            try:
                with open(file_path, 'r') as f:
                    content = f.read()
                self.output_text.setPlainText(content)
                self.current_file = file_path
                self.last_saved_content = content  # Update last saved content
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to open file: {str(e)}")

if __name__ == '__main__':
    app = QApplication(sys.argv)
    app.setStyle('Fusion')
    palette = QPalette()
    palette.setColor(QPalette.ColorRole.Window, QColor(53, 53, 53))
    palette.setColor(QPalette.ColorRole.WindowText, Qt.GlobalColor.white)
    palette.setColor(QPalette.ColorRole.Base, QColor(25, 25, 25))
    palette.setColor(QPalette.ColorRole.AlternateBase, QColor(53, 53, 53))
    palette.setColor(QPalette.ColorRole.ToolTipBase, Qt.GlobalColor.white)
    palette.setColor(QPalette.ColorRole.ToolTipText, Qt.GlobalColor.white)
    palette.setColor(QPalette.ColorRole.Text, Qt.GlobalColor.white)
    palette.setColor(QPalette.ColorRole.Button, QColor(53, 53, 53))
    palette.setColor(QPalette.ColorRole.ButtonText, Qt.GlobalColor.white)
    palette.setColor(QPalette.ColorRole.BrightText, Qt.GlobalColor.red)
    palette.setColor(QPalette.ColorRole.Link, QColor(42, 130, 218))
    palette.setColor(QPalette.ColorRole.Highlight, QColor(42, 130, 218))
    palette.setColor(QPalette.ColorRole.HighlightedText, Qt.GlobalColor.black)
    app.setPalette(palette)
    app.setStyleSheet("QToolTip { color: #ffffff; background-color: #2a82da; border: 1px solid white; }")
    ex = PentestUpdateLogger()
    ex.show()
    sys.exit(app.exec())
